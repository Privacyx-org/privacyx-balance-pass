# PXP-101: Privacyx Balance Pass

- **Standard**: PXP-101  
- **Title**: Privacyx Balance Pass — Zero-Knowledge Balance-Based Access  
- **Author**: Privacyx Labs <support@privacyx.tech>  
- **Type**: Standard (Application-level / ZK)  
- **Status**: Draft  
- **Created**: 2025-11-18  
- **Requires**: zk-SNARK Groth16 verification circuit, Merkle tree commitment  

---

## 1. Summary

PXP-101 defines a standard way for users to prove that they meet a minimum balance
(or similar scalar threshold) **without revealing their address, exact holdings, or raw balance**.

The standard is implemented through:

- an **on-chain access contract** (`BalanceAccessPass`),
- a **zero-knowledge proof circuit** (Balance ≥ Threshold),
- and an **off-chain Merkle tree** representing eligible balances or scores.

PXP-101 is the first module of the broader **Privacyx Standard**.

---

## 2. Motivation

Many Web3 applications need to enforce balance-based eligibility:

- "Only wallets with ≥ X tokens can access this feature."
- "Only LPs with ≥ Y liquidity qualify for premium rewards."
- "Only users with a score ≥ Z can join this private group."

Today, these checks require:

- either fully doxxing a wallet and its on-chain activity, or  
- trusting a centralized backend to perform the check.

PXP-101 solves this by providing a reusable **zero-knowledge access pass**
that is:

- **private** (no raw balances exposed),
- **reusable by integrators** (standard contract interface),
- **one-time per proof** (nullifier-based anti-replay).

---

## 3. Specification

### 3.1. Actors

- **User**: wants to access a gated feature without revealing their balance.
- **Integrator / dApp**: wants to gate a feature based on balance eligibility.
- **Privacyx Operator** (or compatible service): maintains the Merkle tree and publishes roots.

### 3.2. High-level flow

1. The Privacyx Operator builds a Merkle tree of eligible balances or scores.
2. The Merkle root is published and pushed into the `BalanceAccessPass` contract.
3. A user obtains:
   - a Merkle proof for their leaf, and  
   - generates a zero-knowledge proof that:
     - they are a member of the Merkle tree, and  
     - their balance/score is ≥ the required threshold.
4. The user calls `proveAndConsume(...)` on the `BalanceAccessPass` contract with:
   - zk-SNARK proof `(pA, pB, pC)`,
   - public signals: `[root, nullifierHash]`.
5. The contract:
   - verifies the proof using a verifier contract,
   - checks that:
     - `root` is a currently accepted Merkle root,
     - `nullifierHash` has not been used before,
   - marks `nullifierHash` as consumed,
   - emits an `AccessGranted` event.

### 3.3. On-chain interface

The canonical PXP-101 contract interface is:

```solidity
interface IPxp101BalanceAccessPass {
    event AccessGranted(address indexed caller, bytes32 nullifier, uint256 root);

    function currentRoot() external view returns (uint256);
    function requiredThreshold() external view returns (uint256);

    function proveAndConsume(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[2] calldata _pubSignals  // [root, nullifierHash]
    ) external;
}
```

**Where:**

- `currentRoot()` returns the Merkle root currently accepted for proofs.
- `requiredThreshold()` returns the minimum balance/score enforced by this pass.
- `proveAndConsume(...)` MUST:
  - revert if the proof is invalid,
  - revert if `root` is not a known/accepted root,
  - revert if `nullifierHash` has already been used,
  - emit `AccessGranted(caller, nullifierHash, root)` on success.

---

### 3.4. Nullifier semantics

`nullifierHash` MUST be unique per successful access proof.

A contract implementing PXP-101 MUST ensure:

- `nullifierHash` is stored and marked as used upon first successful proof,
- any subsequent use of the same `nullifierHash` MUST revert.

Integrators MAY use `nullifierHash` as a ticket ID, for example:

- to ensure that a user cannot claim a reward twice,
- to correlate an off-chain action with a single on-chain pass.

---

### 3.5. Merkle root management

The standard does not mandate how roots are rotated, but implementations SHOULD support updating the Merkle root over time.

Integrators SHOULD assume that:

- a given root corresponds to a specific snapshot or epoch,
- proofs are only accepted while the root is considered valid.

---

### 3.6. ZK circuit constraints (informative)

A canonical PXP-101 circuit SHOULD enforce:

- a correct Merkle proof for the committed root,
- a balance/score `b` such that `b ≥ threshold`,
- a `nullifierHash` derived from:
  - a secret user identifier (e.g., leaf key),
  - and the Merkle tree context (e.g., root or index).

The exact circuit implementation is out of scope for this spec, but MUST be consistent with the on-chain verifier and public signals.

---

## 4. Rationale

Using a nullifier avoids sharing the explicit wallet address while still providing a unique, one-time “ticket” for integrators.

Using a Merkle tree allows:

- batching eligible users,
- rotating snapshots,
- supporting different data sources (CEX balances, off-chain scores, etc.).

---

## 5. Reference implementation

A reference implementation is deployed on Ethereum mainnet:

- **BalanceAccessPass**: 0x8333b589ad3A8A5fCe735631e8EDf693C6AE0472  
- **Verifier**: 0x34448D78DC8eA25AA6D8eeA46A61e963C1D3C982  

Frontend demo:  
https://pass.privacyx.tech/

Full source code:  
https://github.com/Privacyx-org/privacyx-balance-pass

---

## 6. Security considerations

A compromise of the Merkle tree builder or snapshot source may incorrectly add or remove eligible users.

A bug in the circuit or verifier contract can invalidate privacy guarantees.

Integrators SHOULD:

- verify that they are interacting with the canonical PXP-101 contract,
- treat `AccessGranted` as one signal among others (rate limiting, off-chain checks, or additional business rules).

