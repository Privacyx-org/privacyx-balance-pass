# PXP-102: Privacyx Identity Pass

- **Standard**: PXP-102  
- **Title**: Privacyx Identity Pass — Zero-Knowledge Identity-Based Access  
- **Author**: Privacyx Labs <support@privacyx.tech>  
- **Type**: Standard (Application-level / ZK)  
- **Status**: Draft  
- **Created**: 2025-11-20  
- **Requires**: zk-SNARK Groth16 verification circuit, Merkle tree (or similar) commitment  

---

## 1. Summary

PXP-102 defines a standard way for users to prove that they possess a **valid identity attestation**
issued by a trusted provider (an *Issuer*) **without revealing which identity they are, which wallet
they use, or any raw personal data**.

The standard is implemented through:

- an **on-chain identity access contract** (`IdentityPass`),
- a **zero-knowledge proof circuit** for membership in an attested identity set,
- and an **off-chain Merkle tree (or compatible commitment structure)** representing valid identities.

PXP-102 is the second module of the broader **Privacyx Standard**, focused on **identity / personhood**
rather than balances.

---

## 2. Motivation

Many Web3 and Web2.5 applications need to enforce some notion of “identity validity”:

- "Only verified users can claim this airdrop."
- "Only one account per person can vote in this governance round."
- "Only KYC-verified users can access this product or region."
- "Only one account per human is allowed for this reward."

Today, these flows typically require:

- doxxing a wallet and linking it to centralized KYC data, or  
- trusting a fully centralized backend to handle and verify personal information.

This creates:

- privacy risks for users,
- regulatory burden for protocols,
- and strong incentives for sybil attacks (multiple wallets per user).

PXP-102 solves this by providing a **reusable zero-knowledge identity pass** that is:

- **private** (no identity data or wallet exposed),
- **issuer-agnostic** (supporting multiple identity providers),
- **sybil-resistant** (one identity → one pass per context),
- **non-linkable** between different uses or contexts.

---

## 3. Specification

### 3.1. Actors

- **User**  
  Holds or obtains a valid identity attestation from an Issuer and wants to access
  a gated feature or prove their uniqueness/eligibility without revealing who they are.

- **Integrator / dApp / Protocol**  
  Wants to gate features (claims, voting rights, premium features, region access, etc.)
  based on identity validity or uniqueness, without handling raw identity data.

- **Issuer**  
  A service or protocol that performs identity checks (KYC, proof-of-personhood,
  account verification, etc.), and publishes commitments to a set of valid identities.

  Examples:
  - KYC providers (centralized or decentralized),
  - proof-of-humanity systems,
  - social graph systems with sybil-resistance guarantees,
  - Web2 platforms willing to attest “this person is verified”.

- **Privacyx Operator** (or compatible service)  
  Maintains identity commitment structures (e.g., Merkle trees) and publishes roots
  on behalf of Issuers, or provides infrastructure tooling for them to do so.
  PXP-102 remains **agnostic** about who runs this infra, as long as roots are reliable.

---

### 3.2. Threat model (informal)

PXP-102 is designed to provide:

- **Privacy**:  
  - No raw identity is revealed on-chain.
  - No wallet address needs to be tied to the identity attestation.
  - Multiple uses of the pass SHOULD NOT be trivially correlatable.

- **Sybil resistance (per Issuer / context)**:  
  - A single identity should not be able to claim multiple passes in contexts
    where "one per person" is required (assuming honest Issuer).

- **Issuer flexibility**:  
  - Multiple Issuers can coexist, each with their own identity sets and policies.
  - Integrators MAY choose which Issuers they trust.

PXP-102 does **not** protect against:

- A malicious or compromised Issuer that:
  - adds fake identities,
  - or issues multiple attestations per physical person.
- Collusion between different Issuers at the policy level.
- Off-chain tracking by UIs that combine other signals (IP, device, etc.)

Implementations SHOULD aim to ensure **non-linkability** at the protocol level:
two uses of PXP-102 by the same user in different contexts should not be linkable
via the protocol itself (circuit design, nullifier semantics).

---

### 3.3. High-level flow

1. **Issuer onboarding / Merkle tree construction**

   - An Issuer decides on an identity model (KYC, proof-of-personhood, etc.).
   - For each verified identity, the Issuer (or delegate) creates a **leaf commitment**
     representing that identity (e.g., using a secret identity key + issuer id + metadata).
   - A Merkle tree (or similar commitment) is built over all valid leaves.
   - The Merkle root is published and pushed into an on-chain `IdentityPass` contract
     for a given `issuerId`.

2. **User obtains identity secret**

   - When verified, the user receives or derives a **secret identity key** (ISK),
     used to prove membership in the Issuer’s commitment without revealing which leaf.

3. **User generates a ZK identity proof**

   - The user constructs a zk-SNARK proof that:
     - they possess a valid identity leaf in the Issuer’s tree,
     - the leaf is part of the Merkle tree committed by the published `root`,
     - the identity is **not revoked** (if revocation is part of the design),
     - they derive a **nullifier** tied to:
       - their secret identity key,
       - the Issuer id,
       - and a context or epoch (to control uniqueness vs reusability).

4. **User calls the IdentityPass contract**

   - The user calls `proveIdentity(...)` on the `IdentityPass` contract with:
     - zk-SNARK proof `(pA, pB, pC)`,
     - public signals: `[root, issuerHash, nullifierHash]`.

5. **Contract verifies and consumes**

   The `IdentityPass` contract:

   - verifies the proof via a verifier contract,
   - checks that:
     - `issuerHash` identifies a registered/allowed Issuer,
     - `root` is an accepted root for that Issuer,
     - `nullifierHash` has not been used before,
   - stores `nullifierHash` as consumed,
   - emits `IdentityPassUsed(caller, nullifierHash, issuerHash, root)`.

6. **Integrator consumes the identity signal**

   - Off-chain: by listening to `IdentityPassUsed` events,
   - On-chain: by checking a registry or by calling helper methods.

   The integrator can treat the event or the nullifier as:
   - a “one-time human ticket”,
   - an “identity-verified pass”,
   - or a building block for more complex logic (vote weight, rate limits, etc.).

---

### 3.4. On-chain interface

The canonical PXP-102 contract interface is:

```solidity
interface IPxp102IdentityPass {
    /**
     * @dev Emitted when a valid identity proof is successfully verified and consumed.
     *
     * - `caller`: the EOA or contract that submitted the proof.
     * - `nullifier`: a unique, one-time nullifier derived from the user’s secret identity key
     *   and contextual information.
     * - `issuer`: an identifier for the Issuer (hash or bytes32 id).
     * - `root`: the Merkle root (or commitment) under which the identity is proven.
     */
    event IdentityPassUsed(
        address indexed caller,
        bytes32 indexed nullifier,
        bytes32 indexed issuer,
        uint256 root
    );

    /**
     * @dev Returns the currently accepted Merkle root (or similar commitment) for a given issuer.
     * MUST revert if the issuer is unknown or no root is set.
     */
    function getCurrentRoot(bytes32 issuer) external view returns (uint256);

    /**
     * @dev Returns true if the given nullifier hash has already been used (consumed).
     */
    function isNullifierUsed(bytes32 nullifierHash) external view returns (bool);

    /**
     * @dev Verifies and consumes a zero-knowledge identity proof.
     *
     * `_pubSignals` are expected to be:
     *  - [0] root
     *  - [1] issuerHash
     *  - [2] nullifierHash
     */
    function proveIdentity(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[3] calldata _pubSignals
    ) external;
}

**Where:**

- `getCurrentRoot(issuer)` returns the commitment root associated with a specific Issuer.
- `isNullifierUsed(nullifierHash)` allows integrators to check whether a given nullifier
has already been consumed.
- `proveIdentity(...)` MUST:
  - revert if the proof is invalid,
  - revert if `issuerHash` does not map to a known/authorized Issuer,
  - revert if `root` is not a known/accepted root for that Issuer,
  - revert if `nullifierHash` has already been used,
  - emit `IdentityPassUsed(caller, nullifierHash, issuerHash, root)` on success.

Exact management of Issuers (registration, governance, allowed set of Issuers) is left
to implementations and/or higher-level Governance standards.
  
---

### 3.5. Nullifier & identity semantics

`nullifierHash` MUST be unique per **(identity, context)** combination.

A contract implementing **PXP-102** MUST ensure:

- `nullifierHash` is stored and marked as used upon the first successful proof,
- any subsequent use of the same `nullifierHash` MUST revert.

Implementations SHOULD derive `nullifierHash` *inside the circuit* from:

- the secret identity key (ISK),
- an issuer identifier (issuer id or hash),
- and an optional context or epoch.

This design allows:

- enforcing “one pass per identity per context/epoch” when desirable,
- controlling reusability of the identity pass across different applications,
- preventing trivial linking between uses in different contexts  
  (by varying the context/epoch or using different derivation strategies).

---

### 3.6. Issuer & root management

The standard does not mandate a single Issuer model.

PXP-102 implementers SHOULD support:

- registering multiple Issuers, each with:
  - its own identifier (`bytes32 issuerId`),
  - its own Merkle roots (or similar commitments),
  - rotating roots over time (snapshots, revocations, updates).

Integrators SHOULD assume that:

- a given *(issuerId, root)* pair corresponds to a specific snapshot/epoch of the identity set,
- proofs are only accepted while the *(issuerId, root)* pair is considered valid.

Implementations MAY include:

- admin-controlled Issuer/Root management,
- DAO-governed Issuer/Root management,
- or externalized roots delivered through an oracle-like mechanism.

PXP-102 deliberately leaves governance open-ended and focuses strictly on the
identity-proofing interface and its privacy guarantees.

---

### 3.7. ZK circuit constraints (informative)

A canonical PXP-102 circuit SHOULD enforce:

**Membership proof**
- The prover knows a leaf in the Issuer’s commitment tree, with:
  - a secret identity key `isk`,
  - and possibly auxiliary data (entropy, metadata commitments, etc.).
- The provided Merkle proof is correct with respect to `root`.

**Issuer binding**
- The leaf and/or derived commitments are bound to a specific Issuer id
(or hash), so that:
- an identity from one Issuer cannot be replayed as another Issuer.

**Nullifier derivation**
- `nullifierHash` is derived from:
  - `isk`,
  - `issuerId`,
  - and optionally a context or epoch.
- The derivation SHOULD ensure:
  - uniqueness for a given (isk, issuer, context),
  - resistance against brute-force linking attacks.

**Non-revocation (optional)**
- If revocation is supported, the circuit MAY ensure that the leaf is not
marked as revoked, or that the leaf is within a non-revoked subtree.
The precise circuit design and proving system details are out of scope for this spec
but MUST be consistent with the verifier contract and the expected public signals:
- `[root, issuerHash, nullifierHash]`.

---

## 4. Rationale

PXP-102 intentionally mirrors several design choices from PXP-101:

- **Merkle-based commitments**
Allow batching identities, rotating snapshots, and supporting various
identity sources (KYC providers, proof-of-humanity systems, Web2 platforms, etc.).
- **Nullifier-based anti-replay**
Avoids revealing the user’s wallet while giving integrators a single,
non-reusable “ticket” representing identity validity.
### **Issuer-agnostic design**
Multiple Issuers can coexist and compete, while integrators choose
which Issuers to trust for a given use-case.

PXP-102 does not define what “identity” means at a societal/legal level.
It defines a cryptographic abstraction for turning identity attestations
into privacy-preserving, sybil-resistant passes.

---

## 5. Reference implementation (to be defined)

A canonical implementation of **IdentityPass** is expected to include:

- an on-chain contract implementing `IPxp102IdentityPass`,
- an off-chain Merkle tree builder / root publisher for one or more Issuers,
- a zero-knowledge circuit performing membership + nullifier derivation,
- integration samples (dApp, backend, Privacyx SDK bindings).

Deployment details (chain, addresses, governance) will be specified
once the first implementation is live.

---

## 6. Security considerations

- **Issuer compromise**

If an Issuer is compromised, it may:
  - add fake identities,
  - issue multiple attestations per real person.

This weakens sybil resistance for integrators trusting that Issuer.

- **Circuit or verifier bugs**

A bug in the circuit or verifier contract may allow:
  - forging identity passes,
  - bypassing nullifier constraints,
  - or deanonymizing users.

Implementers SHOULD conduct rigorous audits and formal verification where possible.

- **Linkability via context misuse**
If integrators always use the same context when deriving nullifiers, or
combine on-chain usage data with external signals (IP, browser fingerprint, etc.),
they may reintroduce linkability outside the PXP-102 design.

- **Governance risks**
Centralized control over Issuer or root management can:
  - censor specific identities,
  - or arbitrarily invalidate entire sets.
This is outside the scope of PXP-102, but MUST be considered by any
implementation and ecosystem adopting the standard.

PXP-102 aims to provide a clean, composable identity primitive that can be
adopted by many systems. It does not, by itself, solve all governance, KYC,
or regulatory challenges. It is a privacy-preserving, sybil-aware building block
for identity-based access in Web3.

