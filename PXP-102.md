# PXP-102: Privacyx Identity Pass

- **Standard**: PXP-102  
- **Title**: Privacyx Identity Pass — Zero-Knowledge Identity-Based Access  
- **Author**: Privacyx Labs <support@privacyx.tech>  
- **Type**: Standard (Application-level / ZK)  
- **Status**: Draft  
- **Created**: 2025-11-20  
- **Requires**: zk-SNARK Groth16 verification circuit, Merkle tree (or similar) commitment  

---

## 1. Summary

PXP-102 defines a standard way for users to prove that they possess a **valid identity attestation**
issued by a trusted provider (an *Issuer*) **without revealing which identity they are, which wallet
they use, or any raw personal data**.

The standard is implemented through:

- an **on-chain identity access contract** (`IdentityPass`),
- a **zero-knowledge proof circuit** for membership in an attested identity set,
- and an **off-chain Merkle tree (or compatible commitment structure)** representing valid identities.

PXP-102 is the second module of the broader **Privacyx Standard**, focused on **identity / personhood**
rather than balances.

---

## 2. Motivation

Many Web3 and Web2.5 applications need to enforce some notion of “identity validity”:

- "Only verified users can claim this airdrop."
- "Only one account per person can vote in this governance round."
- "Only KYC-verified users can access this product or region."
- "Only one account per human is allowed for this reward."

Today, these flows typically require:

- doxxing a wallet and linking it to centralized KYC data, or  
- trusting a fully centralized backend to handle and verify personal information.

This creates:

- privacy risks for users,
- regulatory burden for protocols,
- and strong incentives for sybil attacks (multiple wallets per user).

PXP-102 solves this by providing a **reusable zero-knowledge identity pass** that is:

- **private** (no identity data or wallet exposed),
- **issuer-agnostic** (supporting multiple identity providers),
- **sybil-resistant** (one identity → one pass per context),
- **non-linkable** between different uses or contexts.

---

## 3. Specification

### 3.1. Actors

- **User**  
  Holds or obtains a valid identity attestation from an Issuer and wants to access
  a gated feature or prove their uniqueness/eligibility without revealing who they are.

- **Integrator / dApp / Protocol**  
  Wants to gate features (claims, voting rights, premium features, region access, etc.)
  based on identity validity or uniqueness, without handling raw identity data.

- **Issuer**  
  A service or protocol that performs identity checks (KYC, proof-of-personhood,
  account verification, etc.), and publishes commitments to a set of valid identities.

  Examples:
  - KYC providers (centralized or decentralized),
  - proof-of-humanity systems,
  - social graph systems with sybil-resistance guarantees,
  - Web2 platforms willing to attest “this person is verified”.

- **Privacyx Operator** (or compatible service)  
  Maintains identity commitment structures (e.g., Merkle trees) and publishes roots
  on behalf of Issuers, or provides infrastructure tooling for them to do so.
  PXP-102 remains **agnostic** about who runs this infra, as long as roots are reliable.

---

### 3.2. Threat model (informal)

PXP-102 is designed to provide:

- **Privacy**:  
  - No raw identity is revealed on-chain.
  - No wallet address needs to be tied to the identity attestation.
  - Multiple uses of the pass SHOULD NOT be trivially correlatable.

- **Sybil resistance (per Issuer / context)**:  
  - A single identity should not be able to claim multiple passes in contexts
    where "one per person" is required (assuming honest Issuer).

- **Issuer flexibility**:  
  - Multiple Issuers can coexist, each with their own identity sets and policies.
  - Integrators MAY choose which Issuers they trust.

PXP-102 does **not** protect against:

- A malicious or compromised Issuer that:
  - adds fake identities,
  - or issues multiple attestations per physical person.
- Collusion between different Issuers at the policy level.
- Off-chain tracking by UIs that combine other signals (IP, device, etc.)

Implementations SHOULD aim to ensure **non-linkability** at the protocol level:
two uses of PXP-102 by the same user in different contexts should not be linkable
via the protocol itself (circuit design, nullifier semantics).

---

### 3.3. High-level flow

1. **Issuer onboarding / Merkle tree construction**

   - An Issuer decides on an identity model (KYC, proof-of-personhood, etc.).
   - For each verified identity, the Issuer (or delegate) creates a **leaf commitment**
     representing that identity (e.g., using a secret identity key + issuer id + metadata).
   - A Merkle tree (or similar commitment) is built over all valid leaves.
   - The Merkle root is published and pushed into an on-chain `IdentityPass` contract
     for a given `issuerId`.

2. **User obtains identity secret**

   - When verified, the user receives or derives a **secret identity key** (ISK),
     used to prove membership in the Issuer’s commitment without revealing which leaf.

3. **User generates a ZK identity proof**

   - The user constructs a zk-SNARK proof that:
     - they possess a valid identity leaf in the Issuer’s tree,
     - the leaf is part of the Merkle tree committed by the published `root`,
     - the identity is **not revoked** (if revocation is part of the design),
     - they derive a **nullifier** tied to:
       - their secret identity key,
       - the Issuer id,
       - and a context or epoch (to control uniqueness vs reusability).

4. **User calls the IdentityPass contract**

   - The user calls `proveIdentity(...)` on the `IdentityPass` contract with:
     - zk-SNARK proof `(pA, pB, pC)`,
     - public signals: `[root, issuerHash, nullifierHash]`.

5. **Contract verifies and consumes**

   The `IdentityPass` contract:

   - verifies the proof via a verifier contract,
   - checks that:
     - `issuerHash` identifies a registered/allowed Issuer,
     - `root` is an accepted root for that Issuer,
     - `nullifierHash` has not been used before,
   - stores `nullifierHash` as consumed,
   - emits `IdentityPassUsed(caller, nullifierHash, issuerHash, root)`.

6. **Integrator consumes the identity signal**

   - Off-chain: by listening to `IdentityPassUsed` events,
   - On-chain: by checking a registry or by calling helper methods.

   The integrator can treat the event or the nullifier as:
   - a “one-time human ticket”,
   - an “identity-verified pass”,
   - or a building block for more complex logic (vote weight, rate limits, etc.).

---

### 3.4. On-chain interface

The canonical PXP-102 contract interface is:

```solidity
interface IPxp102IdentityPass {
    /**
     * @dev Emitted when a valid identity proof is successfully verified and consumed.
     *
     * - `caller`: the EOA or contract that submitted the proof.
     * - `nullifier`: a unique, one-time nullifier derived from the user’s secret identity key
     *   and contextual information.
     * - `issuer`: an identifier for the Issuer (hash or bytes32 id).
     * - `root`: the Merkle root (or commitment) under which the identity is proven.
     */
    event IdentityPassUsed(
        address indexed caller,
        bytes32 indexed nullifier,
        bytes32 indexed issuer,
        uint256 root
    );

    /**
     * @dev Returns the currently accepted Merkle root (or similar commitment) for a given issuer.
     * MUST revert if the issuer is unknown or no root is set.
     */
    function getCurrentRoot(bytes32 issuer) external view returns (uint256);

    /**
     * @dev Returns true if the given nullifier hash has already been used (consumed).
     */
    function isNullifierUsed(bytes32 nullifierHash) external view returns (bool);

    /**
     * @dev Verifies and consumes a zero-knowledge identity proof.
     *
     * `_pubSignals` are expected to be:
     *  - [0] root
     *  - [1] issuerHash
     *  - [2] nullifierHash
     */
    function proveIdentity(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[3] calldata _pubSignals
    ) external;
}

**Where:**

- `getCurrentRoot(issuer)` returns the commitment root associated with a specific Issuer.
- `isNullifierUsed(nullifierHash)` allows integrators to check whether a given nullifier
has already been consumed.
- `proveIdentity(...)` MUST:
  - revert if the proof is invalid,
  - revert if `issuerHash` does not map to a known/authorized Issuer,
  - revert if `root` is not a known/accepted root for that Issuer,
  - revert if `nullifierHash` has already been used,
  - emit `IdentityPassUsed(caller, nullifierHash, issuerHash, root)` on success.

Exact management of Issuers (registration, governance, allowed set of Issuers) is left
to implementations and/or higher-level Governance standards.
  
---

### 3.5. Nullifier & identity semantics

`nullifierHash` MUST be unique per **(identity, context)** combination.

A contract implementing **PXP-102** MUST ensure:

- `nullifierHash` is stored and marked as used upon the first successful proof,
- any subsequent use of the same `nullifierHash` MUST revert.

Implementations SHOULD derive `nullifierHash` *inside the circuit* from:

- the secret identity key (ISK),
- an issuer identifier (issuer id or hash),
- and an optional context or epoch.

This design allows:

- enforcing “one pass per identity per context/epoch” when desirable,
- controlling reusability of the identity pass across different applications,
- preventing trivial linking between uses in different contexts  
  (by varying the context/epoch or using different derivation strategies).

---

### 3.6. Issuer & root management

The standard does not mandate a single Issuer model.

PXP-102 implementers SHOULD support:

- registering multiple Issuers, each with:
  - its own identifier (`bytes32 issuerId`),
  - its own Merkle roots (or similar commitments),
  - rotating roots over time (snapshots, revocations, updates).

Integrators SHOULD assume that:

- a given *(issuerId, root)* pair corresponds to a specific snapshot/epoch of the identity set,
- proofs are only accepted while the *(issuerId, root)* pair is considered valid.

Implementations MAY include:

- admin-controlled Issuer/Root management,
- DAO-governed Issuer/Root management,
- or externalized roots delivered through an oracle-like mechanism.

PXP-102 deliberately leaves governance open-ended and focuses strictly on the
identity-proofing interface and its privacy guarantees.

---

### 3.7. ZK circuit constraints (informative)

This section describes a **canonical** (but not mandatory) circuit design for PXP-102. Implementations MAY vary, but SHOULD remain compatible with the public inputs:

- `root`
- `issuerHash`
- `nullifierHash`

and with the semantics described below.

#### 3.7.1 Leaf commitment schema

Each Issuer maintains a commitment tree of valid identities.

A canonical PXP-102 leaf is defined as:

text:
leaf = Poseidon( isk , issuerHash , salt )

Where:

isk (Identity Secret Key): a secret 256-bit value associated with a single identity at the Issuer level. It MUST NOT be derived from a wallet address.

issuerHash: a bytes32 identifier for the Issuer (or hash of an Issuer id).

salt: a per-identity entropy or blinding factor, chosen by the Issuer or derived during issuance to prevent brute-force reconstruction of identity sets.

Properties:

The same physical person MAY receive different isk values across different Issuers.

A single Issuer SHOULD NOT issue multiple isk values for the same identity when sybil-resistance is required.

The leaf does not contain any raw PII or wallet address.

The circuit MUST verify that:

- the provided leaf and Merkle path are consistent with the public root,
- the tree structure is consistent with the Issuer’s chosen commitment scheme.

#### 3.7.2 Nullifier derivation & context

PXP-102 relies on nullifiers to provide sybil-resistance and one-time usage per identity and per context, without revealing identity or wallet data.

A canonical nullifier derivation is:

text:
nullifierHash = Poseidon( isk , issuerHash , context )

Where:

isk: the same identity secret key used in the leaf.

issuerHash: binds the nullifier to a specific Issuer.

context: a 256-bit value defining the “scope” of uniqueness and linkability.

The context is a crucial design dimension and SHOULD be chosen according to the integrator’s needs. PXP-102 recommends three main context patterns:

App-bound context (default)

text:
context = keccak256("PXP-102:APP" || appId)

appId: a stable application identifier (e.g., domain, contract address, or UUID).

Ensures: one nullifier per identity per application.

Use-cases:

- “one human = one account” in a dApp.
- anonymous login with sybil-resistance.
- private access to premium features.

App + epoch context

text:
context = keccak256("PXP-102:APP" || appId || "EPOCH" || epochId)

epochId: a time window or logical era (e.g., week number, governance round).

Ensures: one nullifier per identity per application per epoch.

Use-cases:

- recurring anonymous allowances (“N credits per epoch”),
- anti-sybil rate limiting over time,
- recurring gated access or rewards.

Ephemeral / one-shot context

context is chosen randomly or uniquely per use-case (e.g., per session, per ticket).

Ensures: one nullifier per identity per one-shot context, with minimal linkability.

Use-cases:

- highly sensitive interactions,
- single-use anonymous tickets,
- unlinkable proofs for audits or compliance workflows.

The circuit MUST:

- take context as a private input or derive it from other internal inputs,
- derive nullifierHash exactly as expected by the on-chain contract,
- ensure that, for a given (isk, issuerHash, context), the nullifier is unique.

The on-chain contract does not see isk or context, only the resulting nullifierHash.

#### 3.7.3 Public inputs (pubSignals) layout

PXP-102 assumes the following public inputs layout:

text:
_pubSignals[0] = root
_pubSignals[1] = issuerHash
_pubSignals[2] = nullifierHash

The circuit MUST ensure that:

- root matches the Merkle root under which the identity leaf is proven.
- issuerHash corresponds to the Issuer for which the proof is valid.
- nullifierHash is derived from (isk, issuerHash, context) as specified above.

The verifier contract and the on-chain proveIdentity(...) function are responsible for wiring these public signals into the contract’s logic.

#### 3.7.4 Non-revocation (optional extension)

If an implementation supports revocation or dynamic identity sets, the circuit MAY include additional checks, for example:

- proving that the leaf index is not included in a revocation bitmap,
- or that the leaf belongs to a non-revoked subtree committed separately.

These mechanisms are considered extensions and are not mandated by PXP-102. They MUST, however, remain consistent with the public inputs [root, issuerHash, nullifierHash] and the on-chain verification model.

---

## 4. Rationale

PXP-102 intentionally mirrors several design choices from PXP-101:

- **Merkle-based commitments**
Allow batching identities, rotating snapshots, and supporting various
identity sources (KYC providers, proof-of-humanity systems, Web2 platforms, etc.).
- **Nullifier-based anti-replay**
Avoids revealing the user’s wallet while giving integrators a single,
non-reusable “ticket” representing identity validity.
### **Issuer-agnostic design**
Multiple Issuers can coexist and compete, while integrators choose
which Issuers to trust for a given use-case.

PXP-102 does not define what “identity” means at a societal/legal level.
It defines a cryptographic abstraction for turning identity attestations
into privacy-preserving, sybil-resistant passes.

---

## 5. Reference implementation (to be defined)

A canonical implementation of **IdentityPass** is expected to include:

- an on-chain contract implementing `IPxp102IdentityPass`,
- an off-chain Merkle tree builder / root publisher for one or more Issuers,
- a zero-knowledge circuit performing membership + nullifier derivation,
- integration samples (dApp, backend, Privacyx SDK bindings).

Deployment details (chain, addresses, governance) will be specified
once the first implementation is live.

---

## 6. Security considerations

- **Issuer compromise**

If an Issuer is compromised, it may:
  - add fake identities,
  - issue multiple attestations per real person.

This weakens sybil resistance for integrators trusting that Issuer.

- **Circuit or verifier bugs**

A bug in the circuit or verifier contract may allow:
  - forging identity passes,
  - bypassing nullifier constraints,
  - or deanonymizing users.

Implementers SHOULD conduct rigorous audits and formal verification where possible.

- **Linkability via context misuse**
If integrators always use the same context when deriving nullifiers, or
combine on-chain usage data with external signals (IP, browser fingerprint, etc.),
they may reintroduce linkability outside the PXP-102 design.

- **Governance risks**
Centralized control over Issuer or root management can:
  - censor specific identities,
  - or arbitrarily invalidate entire sets.
This is outside the scope of PXP-102, but MUST be considered by any
implementation and ecosystem adopting the standard.

PXP-102 aims to provide a clean, composable identity primitive that can be
adopted by many systems. It does not, by itself, solve all governance, KYC,
or regulatory challenges. It is a privacy-preserving, sybil-aware building block
for identity-based access in Web3.

